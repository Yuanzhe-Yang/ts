
# ALL
1. 记得写type constants
2. 然后写一个reducer 把reducer包装起来变成provider (constant中的那个需要做一个形参)
3. 然后在使用的组件中使用 constant中的那个，然后layout中也用constant中的那个


# Details
## UseRef -- 记忆前一次操作的值

Use time difference during rendering to achieve displaying 前一个值
与子组件建立一个双向通讯的同时，还可以通过`ref`去操作这个组件
[03-UseRef]



## UseContext
### 1. 整体代码逻辑

#### 由两个部分组成 1. 实参 2. 形参
##### 实参 -- 通信协议
	1. 定义在 context/constants.ts 中 -- 就是这个改变从而全局改变  **通信协议**
	2. 实际插入位置: 在 Local 已经设置好之后注入
```typescript
<Locale>
    <DemoAntd>{children}</DemoAntd>
</Locale>
        
const DemoAntd: FC<PropsWithChildren> = ({ children }) => {
	/**
	这里才是注入的地点 ！！！ 注入之后
	*/
    const { locale } = use(LocaleContext);
    const antdLocaleData = useMemo(() => {
        if (!Object.keys(localeData).find((v) => v === locale.name)) {
            return localeData[0];
        }
        return localeData[locale.name];
    }, [locale.name]);

```
	1. 注入之后听从 <Locale>的管教， 在原始 export const Locale: 中设置的是形参
	2. 不管什么时候需要用到具体的就引用这个地址
##### 形参
	1. export const Locale: 定义的
	2. 在代码编写阶段，按钮与这个进行交互
		1. 一般来说会把 自身数据 i.e.Provider和自身变化分开写
		2. Provider 注入 实参



